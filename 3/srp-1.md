# SRP: 단일 책임 원칙

### Single Responsibility Principe (SRP)

하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

**액터 : 이해관계자**

* 모듈은 소스와 데이터 구조로 구성된 응집된 집합이다.
* 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 응집성이다.

#### 단일 책임 원칙을 위반하는 징후

1. 우발적 중복

서로 다른 엑터가 결합된 경우이다. 이런 경우 우발적으로 중복이 생긴다.

2. 병합

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다.

특히 이들 메서드가 서로 다른 엑터를 책임진다면 병합이 발생할 가능성이 높다.

서로 다른 엑터를 뒷받침 하는 코드를 서로 분리해야 한다.

#### 해결책

1. 그들 모두가 각기 다른 모듈로 이동 시키는 방법

#### 퍼사드 패턴

* 퍼사드란 건물의 정면을 의미한다.
* 퍼사드 패턴은 건물의 뒷부분이 어떻게 생겼는지는 보여주지 않고 정면만 보여주는 패턴이다.

서로 엑터가 겹치는 부분의 대해서는 구체적인 구현 대신, 추상적인 부분만 외부로 공개하고 각각의 엑터들의 기능에 대해서는 각각의 클래스가 이를 구현한다.

기존에는 사용자의 변경 사항에 의해 내부 로직까지 모두 변경 되었다면. 지금은 추상 부분에서 순서만 바꿔주면 된다.

어떻게 이럴 수 있을까 하면. 서로 다른 메서드가 연관된 엑터를 책임 지다가, 이제 자기 자신의 엑터만 책임지고. 이를 외부로 제공하는 방식으로 바꾼 다음 실제  사용자에게 제공될 때는 각자가 직접적으로 연관된게 아닌 간접적으로 연관되어있기에 의존성 또한 덜해진다.

컴포넌트도 마찬가지이다. 기능을 만들다보면, 예를 들어 툴팁을 만든다고 하면 툴팁의 트리거가 될 요소와, 툴팁의 메시지가 있을 것 이다.

이 둘을 하나로 합쳐버리면, 사용자의 변경 사항(아이콘을 바꾼다던가, 아이콘이 아닌 다른 요소에 툴팁을 띄운다던가)할 경우 내부 로직을 바꿔야 한다.

* 툴팁의 트리거
* 툴팁의 메시지

이 둘을 따로 분리하고,&#x20;

* 툴팁(트리거에 의해 툴팁 메시지를 on-off해줌)

으로 묶어서 사용자에게 제공한다면. 변경 사항이 생기더라도 툴팁 부분만 변경 하거나 또는 각각의 컴포넌트만 바꾸면 된다.



클래스가 여러 책임을 갖게 되면 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에 클래스는 한 개의 책임만을 가져야한다.

### 책임은 무엇일까?

한 책임의 구현 변경에 의해 다른 책임과 관련된 코드가 변경될 가능성이 높다는 것을 알게 되었다.

기능 변경 요구가 없을 때 수정에 대한 문제가 없다는 것은,

반대로 생각해보면 책임의 단위는 **변화되는 부분**과 관련이 있다는 의미가 된다.

또한 각각의 책임은 서로 다른 이유로 변경되어야 하므로 에를 들어 데이터를 읽어 오는 책임의 기능이 변경될 때 데이터를 보여주는 책임은 변하면 안된다.

어떻게 서로 다른 이유로 변경되는 것을 알 수 있을까?



메소드를 실행하는 것이 누구인지 살펴보는 것이다.

그리고 그 사용자들이 해당 클래스의 서로 다른 메소드들을 사용한다면 그들 메소드는 각각 다른 책임에 속할 가능성이 높다.(책임 분리 후보)



하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

액터는 시스템이 동일한 방식으로 변경되기를 원하는 사용자 집단이다.

엑터는 한 명일수도, 여려 명이 될 수도 있다. 이렇듯 SRP 설계를 할때는 거시적인 관점에서 해당 클래스에 어떤 엑터가 의존하는지 고려하는 것이 바람직하다.

#### 응집성 원칙에 근거하여

책임을 변경하려는 이유로 정의하고, 어떤 클래스나 모듈을 변경하려는 단 하나의 이유만을 가져야 한다고 결론 짓는다.

보고서를 편집하고 출력하는 모듈이라면

1. 편집할 새로운 내용을 받고
2. 기존의 내용을 변경한다.
3. 그리고 내용물을 출력에게 전달한다.

이 모듈은 두 가지 이유로 변경될 수 있다.

1. 보고서의 내용 때문에
2. 보고서의 형식 때문에

하나는 실질적이고, 하나는 꾸미기 위한 매우 다른 원인에 기인한다.

단일 책임 원칙에 의하면 이 문제의 두 측면이 **실제로 분리된 두 책임** 때문이며, 따라서 **분리된 클래스, 모듈로 나누어야 한다.**

다른 시기에 다른 이유로 변경되어야 하는 두 가지를 묶는 것은 나쁜 설계일 수 있다.



























































































































































