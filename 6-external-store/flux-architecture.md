# Flux Architecture

## Flux

***

Flux는 클라이언트-사이드 웹 어플리케이션을 만들기 위해 사용하는 어플리케이션 아키텍처다. 단방향 데이터 흐름을 활용해 뷰 컴포넌트를 구성하는 리액트를 보완하는 역할을 한다.

MVC의 대안으로 내세운 아키텍쳐이며, `2-way binding` 을 썼을 때 생길 수 있는 Model-View 의 복잡한 관계 (전통적인 MVC에선 이런 상황을 지양한다)를 겨냥해 명확히 `“undirectional data flow(단방향 데이터 흐름)”` 를 강조한다.

```
1. Action → 이벤트/메시지 같은 객체.
2. Dispatcher → (여러) Store로 Action을 전달. 메시지 브로커와 유사하다.
3. Store (여러 개) → 받은 Action에 따라 상태를 변경. 상태 변경을 알림.
4. View → Store의 상태를 반영.
```

여기서 더 나아가 Redux는 단일 Store를 사용함으로써 좀 더 단순한 그림을 제안한다.

```
1. Action
2. Store → dispatch를 통해 Action을 받고, 사용자가 정의한 reducer를 통해 State를 변경한다.
3. View → State를 반영.
```

Action을 어떻게 표현하느냐가 사용성에 큰 차이를 만든다. 하지만 상태를 ui에 반영하는 방법은 모두 동일하다.

레이어 아키텍쳐에서 얘기 했던, 3단계 프로세스에 거칠게 매핑하면 다음과 같다.

```
Input -> Action + dispatch
Process -> reducer
Output -> View(React)
```

### Dispatcher, Stores, Views

***

Flux 어플리케이션은 다음 핵심적인 세가지 부분으로 구성되어 있다.

* Movel-View-Controller와 혼동해서는 안된다.
* Controller 도 물론 Flux 어플리케이션에 존재하지만 위계의 최상위에서
  * controller-views - views 관계로 존재하고 있다.
* controller-views: stores에서 데이터를 가져와 그 데이터를 자식에게 보내는 역할을 한다.
* dispatcher 를 돕는 action creator 메소드는 어플리케이션에서 가능한 모든 변화를 표현하는 유의적 API를 지원하는데 사용된다.

### Flux는 MVC와 다르게 단방향으로 데이터가 흐른다.

***

React view에서 사용자가 상호작용을 할 때, 그 view는 중앙의 dispatcher를 통해 action을 전파하게 된다.

어플리케이션의 데이터와 비지니스 로직을 가지고 있는 store는 action이 전파되면 이 action에 영향이 있는 모든 view를 갱신한다.

→ 이 방식은 특히 React의 선언형 프로그래밍 스타일 즉, view가 어떤 방식으로 갱신해야 되는지 일일이 작성하지 않고서도 데이터를 변경할 수 있는 형태에서 편리하다.

## 왜?

***

이 프로젝트는 파생되는 데이터를 올바르게 다루기 위해 시작되었다. 예를 들면

1. 현재 View에서 읽지 않은 메시지가 강조되어 있으면서도
2. 읽지 않은 메시지 수를 상단 바에 표시하고 싶음.

MVC에서는 다루기 어려운 니즈가 있다. → 단일 스레드에서 메시지 스레드 모델을 갱신해야하고 동시에 읽지 않은 메시지 수 모델을 갱신해야 한다. 대형 MVC 어플리케이션에서 종종 나타나는 데이터 간의 의존성과 연쇄적인 갱신은 뒤얽힌 데이터 흐름을 만들고 예측할 수 없는 결과로 이끌게 된다.

Flux는 store를 이용해 제어를 뒤집었다. 일관성을 유지한다는 명목으로 외부의 갱신에 의존하는 방식과 달리 Store는 갱신을 받아들이고 적절하게 조화한다. Store 바깥에 아무것도 두지 않는 방식으로 데이터의 도메인을 관리해야 할 필요가 없어져 외부의 갱신에 따른 문제를 명확하게 분리할 수 있도록 돕는다.

* store를 이용해 제어를 뒤집음
* 기존에는 일관성을 유지한다는 명목 > 외부의 갱신에 의존
* Store는 갱신을 받아들이고 적절하게 조화함.
* Store 바깥에 아무것도 두지 않는 방식으로, 데이터의 도메인을 관리해야할 필요가 없어져 외부의 갱신에 따른 문제를 명확하게 분리 가능

Store는 독립적인 세계를 가지고 있어 setAsRead()와 같은 직접적인 setter 메소드가 없는 대신 dispatcher에 등록한 콜백을 통해 데이터를 받게 된다.

## 구조와 데이터 흐름

***

* 단방향 데이터 흐름은 Flux 패턴의 핵심
* Flux 프로그래머를 위한 제일의 멘탈 모델이 된다.
* dispatcher, store과 view는 독립적인 노드로 입력과 출력이 완전히 구분된다.
* action은 새로운 데이터를 포함하고 있는 간단한 객체로 type 프로퍼티로 구분할 수 있다.

모든 데이터는 중앙 허브인 dispatcher를 통해 흐른다. action은 dispatcher에게 action creator 메소드를 제공하는데 대부분의 action은 view에서의 사용자 상호작용에서 발생한다.

dispatcher는 store를 등록하기 위한 콜백을 실행한 이후에 action을 모든 store로 전달한다. 등록된 콜백을 활용해 store는 관리하고 있는 상태 중 어떤 액션이라도 관련이 있다면 전달해준다.

store는 chagne 이벤트를 controller-views에게 알려주고 그 결과로 데이터 계층에서의 변화가 일어난다. Controller-views는 이 이벤트를 듣고 있다가 이벤트 핸들러가 있는 store에서 데이터를 다시 가져온다.

controller-views는 스스로의 setState() 메소드를 호출하고 컴포넌트 트리에 속해 있는 자식 노드 모두를 다시 렌더링한다.

* 모든 데이터는 중앙 허브인 dispatcher를 통해 흐른다.
* action은 dispatcher에게 action creator 메소드를 제공하는데, 대부분의 action은 view에서의 사용자 상호작용에서 발생한다.
* dispatcher는 store를 등록하기 위한 콜백을 실행한 이후에 action을 모든 store로 전달한다.
* 등록된 콜백을 활용해 store는 관리하고 있는 상태 중 어떤 액션이라도 관련이 있다면 전달해준다.
* store는 change 이벤트를 controller-views에게 알려주고 그 결과로 데이터 계층에서의 변화가 일어난다.
* Controller-views는 이 이벤트를 듣고 있다가 이벤트 핸들러가 있는 store에서 데이터를 다시 가져온다.
* Controller-views는 스스로의 setState() 메소드를 호출하고 컴포넌트 트리에 속해 있는 자식 노드 모두를 다시 렌더링한다.

### **Action Creator**

액션 생성자는 메서드 매개변수에서 액션을 생성하고 유형을 할당하여 dispatcher에서 제공하는 라이브러리에 수집되는 헬퍼 메소드이다.

### **Dispatcher**

모든 작업은 store가 디스패처에 등록한 콜백을 통해 모든 스토어에 전송된다.

### **Store**

스토어는 작업에 대한 응답으로 스스로 업데이트한 후 변경 이벤트를 발생시킨다.

컨트롤러 뷰 라고 하는 특수 뷰는 변경 이벤트를 수신하고 스토어에서 새 데이터를 검색하여 하위 뷰의 전체 트리에 새 데이터를 제공한다.

## 그래서?

***

이 구조는 함수형 반응 프로그래밍을 다시 재현하는 것을 쉽게 만들거나, 데이터-흐름 프로그래밍, 흐름 기반 프로그래밍을 만드는데 쉽도록 돕는다.

어플리케이션에 흐르는 데이터 흐름이 양방향 바인딩이 아닌 단방향으로 흐르기 때문이다.

어플리케이션의 상태는 store에 의해서 관리되고, 다른 부분과는 완전히 분리된 상태로 남는다.

두 store 사이에 의존성이 나타나도 둘은 엄격하게 위계가 관리되어 dispatcher에 의해 동기적으로 변경되는 방법으로 관리된다.

양방향 데이터 바인딩은 연속적인 갱신이 발생하고 객체 하나의 변경이 다른 객체를 변경하게 되어 실제 필요한 업데이트보다 더 많은 분량을 실행하게 된다.

앱의 규모가 커지면 데이터의 연속적인 갱신이 되는 상황에서는 사용자 상호작용의 결과가 어떤 변화를 만드는지 예측하는데 어려워진다.

갱신으로 인한 데이터 변경이 단 한차례만 이뤄진다면 전체 시스템은 좀 더 예측 가능하게 된다.

### 단일 dispatcher

***

* Flux 어플리케이션의 중앙 허브로 모든 데이터의 흐름을 관리한다.
* 본질적으로 store의 콜백을 등록하는데 쓰이고 action을 store에 배분해주는 간단한 작동 방식으로 그 자체가 특별하게 똑똑한것은 아니다
* 각각의 store를 직접 등록하고 콜백을 제공한다. action creator 가 새로운 action이 있다고 dispatcher에게 알려주면 어플리케이션에 있는 모든 store는 해당 action을 앞서 등록한 callback으로 전달 받는다.

### 규모가 커지면..

***

앱의 규모가 커지면 disaptcher의 역할은 더욱 필수적이다. 바로 store 간에 의존성을 특정적인 순서로 callback를 실행하는 과정으로 관리하기 때문이다.

Store는 다른 store의 업데이트가 끝날때까지 선언적으로 기다릴 수 있고 끝나는 순서에 따라 스스로 갱신된다.

## Stores

***

* 앱의 상태와 로직을 포함하고 있다.

MVC의 모델과 역할이 비슷하지만, 많은 객체의 상태를 관리할 수 있는데 ORM 모델이 하는 것처럼 단일 레코드의 데이터를 표현하는 것도 아니고 Backbone의 컬렉션과도 다르다.

* store는 단순히 ORM 스타일의 객체 컬렉션을 관리하는 것을 넘어 애플리케이션 내의 개별적인 도메인 에서 앱 상태를 관리한다.

예를 들어 Facebook의 돌아보기 편집기에서

* 지속적으로 재생된 시간과 플레이어의 상태를 지속적으로 추적하기 위해 TimeStore
* 같은 앱에서 ImageStore는 이미지 컬렉션을 지속적으로 추적한다.

TodoMVC 예제의 TodoStore도 비슷하게 할 일 항목의 콜랙션을 관리한다.

* Store는 두 모델 컬렉션의 특징을 보여주는 것과 동시에 싱글턴 모델의 논리적 도메인으로 역할을 한다.

1. store는 자신을 dispatcher에 등록하고 callback을 제공
2. callback은 action을 파라미터로 받음
3. store는 등록된 callback 내부에서는 액션 타입을 활용하여 액션을 해석하고 store 내부 메소드에 적절하게 연결될 수 있는 훅을 제공한다.
   1. 여기서 결과적으로 action은 dispatcher를 통해 store의 상태를 갱신한다.
4. store가 업데이트 된 후, 상태가 변경되었다는 이벤트를 중계하는 과정으로 view에게 새로운 상태를 보내주고 view 스스로 업데이트하게 만든다.

## Views와 Controller-Views

***

store에게 이벤트를 받으면 store의 퍼블릭 getter 메소드를 통해 새로 필요한 데이터를 처음으로 요청하게 된다. 그 과정에서 setState() 또는 forceUpdate() 메소드를 호출하게 되고, 그 호출 과정에서 자체의 render() 메소드와 하위 모든 자식의 render() 메소드를 실행한다.

때때로 컴포넌트의 단순함을 유지하기 위해 위계 깊은 곳에서 controller-views가 추가적으로 필요할 때가 있다. 중간에 controller-views를 넣으면 특정 데이터 도메인에 관계된 위계 영역을 감싸서 독립적으로 만드는데 도움이 된다. 주의해야할 점은, 위계 내에서 만든 controller-view는 단일의 데이터 흐름과 상충해 잠재적으로 새로운 데이터 흐름의 시작점에서 충돌할 수 있다.

내부에 controller-view를 추가하는 것을 결정할 때에는 여러 데이터 업데이트의 흐름이 위계와 다른 방향으로 흐르지 않도록 고려해 단순함의 균형을 유지해야 한다.

여러 데이터 업데이트 → 이상한 효과를 만들어 → React의 렌더링 메소드가 다른 controller-view에 의해 반복적으로 실행되서 → 디버깅의 어려움을 가중할 가능성이 있다.

내부 controller-view를 만드는 것을 결정할 때, 데이터를 갱신하기 위해 위계에서 여러 방향으로 흐르는 복잡성에 반해 단순한 컴포넌트의 이점에서 균형을 찾아야 한다.

여러 방향으로의 데이터 갱신은 이상한 효과를 만들 수 있다. 특히 React의 렌더 메소드는 여러 controller-view를 갱신하기 위해 반복적으로 실행이 됨.

## Dispatcher에 대해서

***

* 앞서 언급한 것처럼 dispatcher는 store 간의 의존성을 관리할 수 있다.

## 요약

***

* 확장 가능하고 유지 관리가 가능한 웹 애플리케이션을 구축하는 데 사용되는 아키택처 패턴이다.
* Flux의 주요 목표는 애플리케이션, 특히 **복잡한 사용자 인터페이스**가 있는 애플리케이션의 **데이터 흐름을 단순화**하고 **애플리케이션 동작의 예측 가능성을 향상**

### Flux Architecture 를 사용하는 이유

***

1. **단방향 데이터 흐름**
   1. 애플리케이션의 데이터가 명확하고 예측 가능한 경로를 갖는다.
2. **상태 변경을 예측할 수 있으며, 엄격한 흐름을 따른다.**
   1. 예측 가능성 덕분에 애플리케이션의 한 부분의 변경이 나머지 부분에 어떤 영향을 미치는지 디버깅 및 추론이 쉬워진다.
3. **중앙 집중 데이터 저장소: Store**
   1. 애플리케이션의 상태를 보관하는 중앙 집중식 데이터 저장소라는 개념을 도입 → 상태를 관리, 변경 이벤트를 발생시키는 역할을 함
4. **Actions**
   1. 시스템의 변화를 설명하는 이벤트. Flux에서 컴포넌트는 액션을 트리거하여 어떤 일이 발생했음을 알림.
   2. 액션 → 스토어 → 상태 업데이트 전파
5. **컴포넌트 디커플링**
   1. Flux는 컴포넌트를 분리하는 데 도움을 준다. 컴포넌트는 서로를 직접 인식하지 않고, 액션과 중앙 저장소를 통해 통신한다.
   2. 대규모 애플리케이션의 복잡성을 더 쉽게 관리할 수 있다.
6. **디버깅의 용이성**
   1. 단방향 데이터 흐름, 명확한 문제 분리로 애플리케이션을 더 쉽게 디버깅할 수 있다.
7. **비동기 작업 지원**
   1. 서버 요청과 같은 비동기 작업을 자연스럽게 처리할 수 있는 방법을 제공한다.
