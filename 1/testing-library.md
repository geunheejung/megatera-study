# Testing Library

### JEST

거의 모든 것을 갖춘 테스팅 도구!



"F/E 테스트 = only React 컴포넌트 테스트" 가 되는 상황은 최대한 피하는 게 좋다.

본질에 집중하지 못하고 너무 많은 테스트 코드를 작성할 위험이 있다.

유지 보수를 돕기 위해 테스트 코드를 작성하는데,&#x20;

**테스트 코드를 잘못 작성하며 오히려 유지보수를 저해한다.**

#### **프론트엔드도 TDD?**

* 자주 바뀔만한 부분의 대해서는 테스트 하지 않는다.
* UI를 직접적으로 컨트롤 하지 않고 UI와 연결된 이를 처리 하는 컨트롤러, 모델, 서비스들을 분리해서 테스트 하자
  * 화면에 특정 데이터를 보여준다 했을 때, 렌더링 라이브러리 또는 프레임 워크 사용 시 그려지는건 잘 그려진다. 대신에 연결되는 데이터의 대해서 그리고 데이터를 불러오는 과정에 대해서 테스트 하자.
  * 만약, 장바구니라 하면. 화면에 장바구니가 그려지는걸 테스트 하기 보다 장바구니 데이터 안에 같은 데이터가 들어가느냐에 대한 데이터 쪽 테스트를 진행하는 것이다.
* 테스트를 해야할 부분과, 안해도 될 부분을 분리하고 -> 해야될 부분을 늘려가자.
  * 관심사의 분리 -> 프로그램의 구조 -> 구조가 좋아질수록 테스트가 수월해진다.

#### Mocking 때문에 테스트 코드 어렵다?

* Mocking을 하는 이유
  * 빨리, 생산성 있게 개발 하기 위함.
  * Mocking을 많이 쓰기 위한 목적이 아니다.
* 구조가 문제가 아니다. -> 테스트를 작성하고 있는 부분이 본질이 아닐 가능성이 매우 크다.
  * 코어 레벨로 갈수록 Mocking을 할 이유가 줄어든다.
    * parseInt 와 같은 내장 메서드 또는 로직만 담긴 헬퍼 함수일 것 같다
  * 애플리케이션 레이어를 테스트 과정에서 문제가 있다면 -> 도메인 객체한테 올바르게 도메인 로직이나 비지니스 로직을 넘기지 않는다는 것
  * UI 레이어를 너무 많이 처리한다 -> 우리가 만들고 있는게 핵심에 다가가는게 아님.
* 생산성을 높이고 품질을 높이는것이 주요 목적이다. + 속도
* 빠른 속도와 좋은 품질을 집중하자 -> Mocking을 적게 하고 Mock이 사실상 거의 쓰이지 않는 부분에 총력을 기울이기 위해서이다.
* 아키텍처, 설계는 경계를 만드는 행위고, 경계를 찾는데에서 모든 문제가 출발한다.

#### 실제로 해보자!

```typescript
// Some code


test('숫자 더하기', () => {
  expect(add(1, 2)).toBe(3);  
});

```

1. 먼저 테스트를 만든다.
2. 테스트를 실행 시킨다. -> 에러가 난다.
3. 하나씩 테스트를 충족 시킨다.

<pre class="language-typescript"><code class="lang-typescript"><strong>test('숫자 더하기', () => {
</strong>  const add = (x: number, y:number) => 1 + 2;
  expect(add(1, 2)).toBe(3);  
});
</code></pre>

4. 수정을 테스트가 통과 되는걸 확인 해가면서 한다.

```typescript
// Some code
  const add = (x: number, y:number) => x + 2; // 통과
  const add = (x: number, y:number) => x + y; // 통과
```

테스트를 믿고서 하나씩 하나씩 변경 해가면서 확인 하는것이다!

#### BDD

* 행동을 묘사한다

```typescript

// Some code
const context = describe;
// BDD: 행동을 묘사한다.
describe('add 함수는', () => {
  context('두 개의 양수가 주어졌을 때', () => {
    it('두 숫자의 합을 돌려준다', () => {
      expect(add(1, 2)).toBe(3);
    })

    it('항상 두 개의 숫자보다 큰 값을 돌려준다', () => {
      expect(add(1, 2)).toBeGreaterThan(1);
      expect(add(1, 2)).toBeGreaterThan(2);
    });    
  });

  context('하나의 양수와 음수가 주어지면', () => {
    it('항상 하나의 양수보다 작은 값을 돌려준다.', () => {
      expect(add(1, -2)).toBeLessThan(1)
    })
  })
  
})
```

* 어떻게 행동의 대해 표현하느냐에 따라 테스트가 구체적일 것 같다.
* 표현의 대해 고민 하게 된다.

해당 기능의 대한 행동들에 대해 잘 고민할수록 좋은 테스트 코드가 될 거 같다!

