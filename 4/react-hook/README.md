# React Hook

### Hook은 알고 있는 React 컨셉을 대체하지 않는다.

대신에 훅은 props, state, context, refs, lifecycle 와 같은 React 개념에 좀 더 직관적인 API를 제공한다.

### 동기

#### (1) 컴포넌트 사이에서 상태 로직을 재사용하기 어렵다.

컴포넌트간에 재사용 가능한 로직을 붙이는 방법을 제공하지 않는다.(예를 들어, 스토어에 연결 하는 것, 온.오프라인 모드에 따라 특정 행위를 취하는 것)&#x20;

이전부터 리액트를 사용해왔다면, render props 나 hoc 와 같은 패턴을 통해 이러한 문제를 해결하는 방법에 익숙할 것이다. 그러나 이런 패턴의 사용은 (1) 컴포넌트의 재구성을 강요, (2) 코드의 추적을 어렵게 만든다.&#x20;

리액트 개발자 도구에서 리액트 애플리케이션을 본다면, providers, consumers, hoc, render props 그리고 다른 추상화에 대한 레이어로 둘러싸인 "Wrapper 지옥" 을 볼 가능성이 높다.

\= React는 상태 관련 로직을 공유하기 위해 좀 더 좋은 기초 요소가 필요했다.

#### (2) 복잡한 컴포넌트들은 이해하기 어렵다

관리하기가 힘들어지는 상태 관련 로직들과 사이드 이펙트가 있는 컴포넌트들을 유지보수해야 한다.

* 각 생명주기 메서드에는 자주 관련 없는 로직이 섞여들어가고는 한다.

componentDidMount: 데이터 패칭 O, 이벤트 리스너 등록 X

함께 변경되는 상호 관련 코드는 분리되지만 이와 연관 없는 코드들은 단일 메서드로 결합한다.

* 이로 인해 버그가 쉽게 발생하고 무결성을 너무나 쉽게 해친다.

위와 같은 예시에서, 상태 관련 로직은 한 공간안에 묶여 있기 때문에 이런 컴포넌트들을 작게 분리하는 것은 불가능하며 테스트하기도 어렵다. 이 때문에 많은 사용자들은 React를 별도의 상태 관리 라이브러리와 함께 결합해 사용함.&#x20;

* 상태 관리 라이브러리는 너무 많은 추상화, 서로 다른 파일들 사이에서 건너뛰기를 요구 = 재사용성을 더욱 어렵게 만듬.



이와 같은 문제를 해결하기 위해, 생명주기 메서드를 기반으로 쪼개는 것 보다는.

**Hook을 통해 서로 비슷한 것을 하는 작은 함수의 무끙ㅁ으로 컴포넌트를 나누는 방법을 사용할 수 있다.**

#### (3) Class는 사람과 기계를 혼동시킨다.

* Class는 코드의 최소화를 힘들게 만들고
* 핫 리로딩을 깨지기 쉽고 신뢰할 수 없게 만든다
* 코드가 최적화 가능한 경로에서 유지될 가능성이 더 높은 API를 제공하기를 원함



이러한 문제를 해결하기 위해, **Hook은 Class없이 React 기능들을 사용하는 방법을 제시한다.**

개념적으로 React 컴포넌트는 항상 함수에 더 가깝다.&#x20;



### Detailed design

* 한 Hook에서 반환된 값을 다른 Hook으로 전달할 수 있다. 예를 들어 이펙트는 자동으로 함수 범위 안에 있기 때문에 useState에서 반환값을 읽을 수 있다.
* 커스텀 Hook을 사용하면 React의 특별한 개입 없이 로직을 추상화할 수 있다.
* 단일 this.state 객체 대신 useState호출당 하나의 변수를 사용하면 VM이 최적화하기 어려운 객체 속성 액세스가 줄어든다.
* state변수 이름(useState 포함)은 자동으로 최소화할 수 있다.
* 빌드 툴링을 변경할 필요가 없다.

#### 단점

* "Rules of Hooks" : 일부 유형의 리팩터링을 더 어렵게 만들 수 있다. 컴포넌트에 조기 리턴을 추가 하려면 모든 Hook 호출을 해당 조건문 이전으로 이동하지 않으면 더 이상 불가능하다.
* 이벤트 핸들러는 최신 props, state를 참조하기 위해 렌더링할 때마다 다시 생성해야 하므로 PureComponent, React.memo의 효율성이 떨어진다.
* 클로저(useEffect, useCallback에 전달된 클로저와 같은)가 이전 버전의 props 및 state 값을 캡쳐할 수 있다. 특히 "inputs" 배열에 캡쳐된 변수 중 하나가 실수로 누락된 경우 이런 일이 발생한다. 이는 혼란스러움
  * 의존성 배열 관련
* React는 각 Hook이 호출될 때 어떤 컴포넌트가 현재 렌더링 중인지 결정하기 위해 내부 전역 상태에 의존한다. "덜 순수"하며 직관적이지 않을 수 있음.&#x20;
* shouldeComponentUpdate를 대체하는 : React.memo는 이전 props, 새 props에만 접근할 수 있으며, 중요하지 않은 상태 업데이트를 위해 재렌더링을 건너띌 수 있는 쉬운 방법이 없다.



































































































