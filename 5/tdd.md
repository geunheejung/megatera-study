# TDD

### TDD(Test Driven Development)

***

> 테스트 코드를 먼저 작성하는, 즉 구현보다 인터페이스와 스펙을 먼저 정의함으로서 개발을 진행하는 방식.

#### 간략히..

1. 테스트를 추가하고
2. 실패하도록 하고
3. 테스트를 통과하는 코드를 작성한다.

\= 코드 단계에서 이미 클라이언트와 테스트 릭이라는 두 명의 사용자를 가지고 있기 때문에 고도로 분리되어 재사용이 용이하다.

#### 자세히..

* 무엇을 하고 싶은지 생각
* 어떻게 테스트할지 생각
* 간단한 테스트를 작성 : eg) 원하는 API에 대해 생각
* **테스트에 실패할 만큼만 코드를 작성**
* 테스트를 실행하고 실패하는 것을 알았다.
* **테스트를 통과할 수 있을 만큼만 코드를 작성**
* 실행 후 모든 테스트가 통과 되는지 확인.
  * 통과하지 못하면 뭔가 잘못한 것이므로 방금 작성한 내용일 테니 **지금 수정하세요.**
* 중복되는 로직, 표현력이 부족한 코드가 있다면 리팩터링하여 중복을 제거, 표현력을 높임.
  * 결합은 줄이고, 응집력을 높이는 작업이 포함된다.
* 테스트를 다시 실행
  * 통과하지 못하면 리팩터링에 실수가 있는 것 이다.

\= 새 코드 작성을 유도하는 테스트를 더 이상 찾을 수 없을 때까지 위의 단계를 반복한다.

#### (1) 무엇을 하고 싶은지 생각, (2) 어떻게 테스트할지 생각

첫 번째 항목이 가장 어렵고 그 다음이 두 번째 항목이다. 하지만 이 두가지를 할 수 없다면 코드 작성을 시작하지 않는 것이 좋다.

1. 무엇을 하고 싶은지 생각 👉 온사이트 고객이 계속 외치는 내용
2. 어떻게 테스트할지 생각 👉 항목(1)을 뒤집어서 설명한 것이다.

특히 이 순서대로 하면 모두 쉽다.

> 현장 고객의 말을 듣는 것과 그 의미를 이해하는 것 사이에는 큰 차이가 있다. 비지니스 명세서를 기술 언어로 번역하는 것은 어려운 작업이 될 수 있으며 그 어려움을 존중해야 한다.

항목(2)는 코드를 테스트하려면 최종 사용자가 반드시 필요로 하지 않는 일부 사항을 노출해야 하는 경우가 많다는 점을 인식한다. 사용자가 필요로 하는 것을 넘어 테스트에 필요한 것까지 고려해야 하는 단계가 있다.

>

#### Test-first programming 이 design에 영향을 미칠 수 있는 방법의 목록

* 재사용이 좋다. 테스트 우선 코드는 두 개의 클라이언트로 시작된다. 따라서 세 번째 클라이언트를 쉽게 추가할 수 있다.
* 테스트 우선 코드를 리팩터링하면 동일하게 테스트된 코드가 생성되므로 더 공격적인 리팩터링이 가능하다.
  * 일반적으로 코드가 더 많은 리팩터링을 수용하기에 더 좋은 상태이다.
* 모든 작은 단계에 주의를 기울이면 코드에서 패턴을 발견할 수 있다.
* 테스트 코드는 작성하기 쉽다. 그리고 쉬운 코드를 먼저 작성하면 어려운 코드를 쉽게 작성할 수 있다.
* 디자인패턴은 처음부터 한꺼번에 추가하는 것이 아니라 점진적으로 추가할 수 있다.
* 테스트 우선 코드는 인터페이스를 먼저 작성한다. 기능을 보여줄 수 있는 가장 단순한 인터페이스를 생각한다.
* 코드는 덜 결합되는 경향이 있다. 효과적인 단위 테스트는 한 가지만 테스트한다. 이렇게 하기 위해선 관련 없는 부분(예: 모의 객체)을 제거해야 한다. 이렇게 하면 잘못된 디자인 선택일 수 있는 부분을 제거할 수 있다.
* 유닛테스트는 객체 사용에 대한 표준 및 테스트 문서 역할을 한다. 이를 통해 프로젝트가 순조롭게 진행된다.
* 개발자가 수행할 작업에 대한 테스트를 작성해야 할 때, 불필요한 기능을 추가할 가능성이 훨씬 줄어든다. **이는 개발자가 주도하는 범위 확장을 억제한다.**
* 테스트 우선 설계를 사용하면 무엇을 할 것인지에 대해 정말로 생각하게 된다. **“당시에는 좋은 아이디어 같았어요”** 라는 식의 프로그래밍에서 벗어날 수 있다.

#### TDD 의 세 가지 원칙

1. 테스트는 애플리케이션 코드에서 버그를 찾는 데 도움이 되며, tdd를 통해 취한 미세한 단계는 모든 “버그”가 방금 작성한 바로 그 코드에 있다는 것을 의미하므로 여전히 작은 두뇌에 관련 멘탈 모델이 있다.

\= 버그의 발견이 현재의 시점 내지는 조금 더 나아간 시점 안에서 이뤄지기에 나의 뇌 컨텍스트가 여전히 해당 시점에 남아있다. (개인 해석)

1. 각 테스트를 실행하기 위해 애플리케이션 코드에서 가장 간단한 작업을 수행하다 보면, 지나치게 구체적인 코드(즉, 테스트가 작동할 수 있을정도로만)를 작성하여 테스트가(실행되더라도) ‘실제’ 요구 사항을 충족하기에 충분하지 않다는 것을 알게 되는 작은 깨달음의 순가이 종종 있다. 따라서 더 추상적인 애플리케이션 코드 작성을 정당화하기 위해 추상화를 요구하는 테스트 사례를 더 추가해야 하며, 이로 인해 요구 사항을 더 자세히 살펴봐야 한다. 애플리케이션 코드는 실제로 테스트를 디버깅하는 데 도움이 된다. 그리고 테스트가 사양이기 때문에 애플리케이션 코드의 피드백은 사양을 디버깅하는 데 도움이 된다.

\= 테스트를 통과 시키고, 중복되는 로직-표현력이 부족한 코드를 리팩터링 하고, 이를 위해 테스트를 작성하고, 그 사이에서 요구 사항에 대한 테스트 케이스는 추상화를 하는데 피드백이 되고, 추상화에 대한 테스트 케이스는 요구 사항을 더 자세히 살펴보게 하게 해준다. (개인 해석)

* “아하” 하는 순간(위 2번에서 언급한)이 오면 Kent의 방법에 따라 ‘할 일 목록’ 에 추가한다. 할 일 목록은 내가 지속적으로 우선순위를 정하는 마이크로 스토리의 목록이다.(이 단계에서 고객은 나 이니깐). 스토리는 고객과의 대화에 대한 약속이라는 AlistairCockburn의 통찰에 따라, 할 일 목록의 마이크로 스토리가 코드와의 대화에 대한 약속이라는 것을 알았다.( 코드가 나에게 피드백을 주고, 무언가를 알려주며, tdd가 코드에 귀 기울이도록 조율한다)

### 단위 테스트와 TDD

***

* `단위 테스트` : 구현에 대한 테스트
* `TDD` : 자동화된 단위 테스트 코드를 먼저 작성함으로써 테스트가 개발을 이끌어나가도록 하는 방식

자동화된 단위 테스트는 우리가 기대한 올바른 결과가 나오는 걸 전제로 한다. TDD는 인터페이스와 예제, 기대하는 결과를 먼저 작성하는 걸로 시작한다. 단위 테스트 코드를 작성한다는건 이미 설계가 어느 정도 된 상태, 즉 인터페이스와 예제가 만나는 지점을 묘사할 수 있는 상태를 전제로 한다.

```jsx
// 실패
assertEqual(1, Math.square(1));

// 통과
Math.square = (x) => {
    return 1;
};

assertEqual(1, Math.square(1));

// 실패: 테스트 추가
assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));

// 통과: 방금 실패한 테스트
Math.square = (x) => {
    if (x === 2) {
        return 4;
    }
    return 1;
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));

// 리팩터링: 의도 를 드러낸다. 4 = 2의 제곱
Math.square = (x) => {
    if (x === 2) {
        return x * x;
    }
    if (x === 1) {
        return x * x;
    }
};

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));

// 리팩터링: 공통된 부분을 합침(중복 제거), 테스트 추가
Math.square = (x) => x * x;

assertEqual(1, Math.square(1));
assertEqual(4, Math.square(2));
assertEqual(9, Math.square(3));

// 리팩터링: 구체적인 코드를 추상화 👉 sqaure를 Math란 네임스페이스 안에 묶지 않고, 숫자(Number)로
assertEqual(1, (1).square());

// 실패: 방금 진행한 리팩터링에서 문제가 있음을 현 시점에서 인지할 수 있다.
Number.prototype.square = function () {
    return Math.square(this);
}

assertEqual(1, (1).square());

// 리팩터링: inline method
Number.prototype.square = function () {
    return this * this;
}

assertEqual(1, (1).square());
assertEqual(4, (2).square());
assertEqual(9, (3).square());
```

> 우리의 사고 과정을 작은 단계로 나누고, 각 단계를 코드로 적고 검증하면서 진행할 수 있다.

* ”이건 대단히 복잡한 일이야” 라고 하면서 한번에 커다랗게 쓰는 것 밖에 할 수 없는 사람
* ”이건 대단히 복잡하니 작게 나눠서 진행하겠어” 라고 말하고 노력하는 사람

#### 작업을 작게 나눠 진행 후 테스트를 나중에

***

작업을 작게 나눌 수 있다면 테스트 코드를 나중에 적는 것도 가능하다. 다만, 확신의 정도가 조금 다르다. 확실히 실패하는 상황에서 성공하는 상황으로 전환했는지, 아니면 무언가 잘못해서 우연히 성공하는 상태에 코드를 더한건지 알아채기 어렵다.

TDD는 테스트 코드를 먼저 작성하는 것이 전부가 아니다. 테스트 코드를 작성하고, 테스트가 실패하는 걸 확인한다. 테스트가 확실히 실패하는 걸 확인하지 않고 넘어갈 경우 사소한 실수를 발견한다.

테스트 케이스를 꼼꼼히 검토함으로써 해결할 수는 있지만, 이런 문제를 가장 빨리 확인할 수 있는 건 “나중”이 아니라 “바로 지금”이다. 나중에 발견할수록 비용은 점점 커진다.

#### 뭘 테스트해야 할지

***

1. 간단한 프로토타입을 만들고 어떤 가능성을 보게 됐을 때 프로토타입 코드를 모두 지우고 제대로 된 코드를 TDD로 진행한다.(버전 컨트롤, 브랜치 기능 활용) ⇒ 제품에 가까운 실험을 재빨리 진행 시도.
2. 더 작은 단위 또는 더 큰 단위로 시도한다. 책장을 넘기는 작업에 집중하지 않고 책을 본다는 행위에 집중하거나, 글자 하나를 본다는 작업에 집중하다가 한꺼번에 너무 많은 글자가 나오는 게 아닌가 하는 문제에 다다랐을 때 페이지 분할 및 페이지 전환에 집중해 책장 넘김을 유도한다.

#### 그래도 어렵다

***

> “테스트” 라는 말이 가지는 고정 관념(마구잡이로 실행해 보고 우연히 버그를 찾아내는..)

정확히 뭘 만들어야 하는지 목록을 만들자. 분명한 스펙이 정해지지 않았다면 이 일이 어려울 수 있지만, 분석, 설계 단계에서 미흡한 게 원인일 수도 있고, 그냥 개발자가 직접 결정해야 하는 문제일 수도 있다.

👉 **정확히 무엇이 원인일지 추측해 보자.**

스펙이 명확하다면 그걸 어떻게 사용할지 간단한 예제 코드를 작성해보자. 미리 인터페이스를 생각해보는 것.

```jsx
var human = new Human({
    name: '강동원'
});

human.on('talk', function () {
    return '나는 ' + this.alias() + '다.';
});

assertEqual('강동원: 나는 강참치다.', human.talk());
```

한번에 만들지 않고, 실제로는 각 단계를 나눠서 진행할 수 있다.

#### 적용하기 위한 전제

***

어떤 일을 하는지 명확해야 한다. 각 작업이 있으면 더 좋다.

올바른 결과가 무엇인지 알기 어렵다면, TDD를 하기 어렵다.
